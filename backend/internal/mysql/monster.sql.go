// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: monster.sql

package mysql

import (
	"context"
	"database/sql"
	"time"
)

const createMonster = `-- name: CreateMonster :execresult
INSERT INTO Monster (MonsterId, Nickname, OriginalTrashBinImageUrl, GeneratedMonsterImageUrl, Latitude, Longitude)
VALUES (?, ?, ?, ?, ?, ?)
`

type CreateMonsterParams struct {
	Monsterid                  string         `json:"monsterid"`
	Nickname                   string         `json:"nickname"`
	Originaltrashbinimageurl   string         `json:"originaltrashbinimageurl"`
	Generatedmonsterimageurl   string         `json:"generatedmonsterimageurl"`
	Latitude                   sql.NullString `json:"latitude"`
	Longitude                  sql.NullString `json:"longitude"`
}

func (q *Queries) CreateMonster(ctx context.Context, arg CreateMonsterParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createMonster,
		arg.Monsterid,
		arg.Nickname,
		arg.Originaltrashbinimageurl,
		arg.Generatedmonsterimageurl,
		arg.Latitude,
		arg.Longitude,
	)
}

const deleteMonster = `-- name: DeleteMonster :exec
DELETE FROM Monster
WHERE MonsterId = ?
`

func (q *Queries) DeleteMonster(ctx context.Context, monsterid string) error {
	_, err := q.db.ExecContext(ctx, deleteMonster, monsterid)
	return err
}

const getMonster = `-- name: GetMonster :one
SELECT monsterid, nickname, originaltrashbinimageurl, generatedmonsterimageurl, latitude, longitude, createdat, updatedat FROM Monster
WHERE MonsterId = ? LIMIT 1
`

func (q *Queries) GetMonster(ctx context.Context, monsterid string) (Monster, error) {
	row := q.db.QueryRowContext(ctx, getMonster, monsterid)
	var i Monster
	err := row.Scan(
		&i.Monsterid,
		&i.Nickname,
		&i.Originaltrashbinimageurl,
		&i.Generatedmonsterimageurl,
		&i.Latitude,
		&i.Longitude,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const getMonsterDetail = `-- name: GetMonsterDetail :one
SELECT
    m.MonsterId,
    m.Nickname,
    m.OriginalTrashBinImageUrl,
    m.GeneratedMonsterImageUrl,
    m.Latitude,
    m.Longitude,
    m.CreatedAt,
    m.UpdatedAt,
    ma.AttributeName,
    ma.ColorCode
FROM Monster m
LEFT JOIN MonsterAttribute ma ON m.MonsterId = ma.MonsterId
WHERE m.MonsterId = ? LIMIT 1
`

type GetMonsterDetailRow struct {
	Monsterid                  string         `json:"monsterid"`
	Nickname                   string         `json:"nickname"`
	Originaltrashbinimageurl  string         `json:"originaltrashbinimageurl"`
	Generatedmonsterimageurl  string         `json:"generatedmonsterimageurl"`
	Latitude                   sql.NullString `json:"latitude"`
	Longitude                  sql.NullString `json:"longitude"`
	Createdat                  time.Time      `json:"createdat"`
	Updatedat                  time.Time      `json:"updatedat"`
	Attributename              sql.NullString `json:"attributename"`
	Colorcode                  sql.NullString `json:"colorcode"`
}

func (q *Queries) GetMonsterDetail(ctx context.Context, monsterid string) (GetMonsterDetailRow, error) {
	row := q.db.QueryRowContext(ctx, getMonsterDetail, monsterid)
	var i GetMonsterDetailRow
	err := row.Scan(
		&i.Monsterid,
		&i.Nickname,
		&i.Originaltrashbinimageurl,
		&i.Generatedmonsterimageurl,
		&i.Latitude,
		&i.Longitude,
		&i.Createdat,
		&i.Updatedat,
		&i.Attributename,
		&i.Colorcode,
	)
	return i, err
}

const listMonsters = `-- name: ListMonsters :many
SELECT monsterid, nickname, originaltrashbinimageurl, generatedmonsterimageurl, latitude, longitude, createdat, updatedat FROM Monster
ORDER BY CreatedAt DESC
`

func (q *Queries) ListMonsters(ctx context.Context) ([]Monster, error) {
	rows, err := q.db.QueryContext(ctx, listMonsters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Monster{}
	for rows.Next() {
		var i Monster
		if err := rows.Scan(
			&i.Monsterid,
			&i.Nickname,
			&i.Originaltrashbinimageurl,
			&i.Generatedmonsterimageurl,
			&i.Latitude,
			&i.Longitude,
			&i.Createdat,
			&i.Updatedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonstersWithAttribute = `-- name: ListMonstersWithAttribute :many
SELECT
    m.MonsterId,
    m.Nickname,
    m.OriginalTrashBinImageUrl,
    m.GeneratedMonsterImageUrl,
    m.Latitude,
    m.Longitude,
    m.CreatedAt,
    m.UpdatedAt,
    ma.AttributeName,
    ma.ColorCode
FROM Monster m
LEFT JOIN MonsterAttribute ma ON m.MonsterId = ma.MonsterId
ORDER BY m.CreatedAt DESC
`

type ListMonstersWithAttributeRow struct {
	Monsterid                 string         `json:"monsterid"`
	Nickname                  string         `json:"nickname"`
	Originaltrashbinimageurl  string         `json:"originaltrashbinimageurl"`
	Generatedmonsterimageurl  string         `json:"generatedmonsterimageurl"`
	Latitude                  sql.NullString `json:"latitude"`
	Longitude                 sql.NullString `json:"longitude"`
	Createdat                 time.Time      `json:"createdat"`
	Updatedat                 time.Time      `json:"updatedat"`
	Attributename             sql.NullString `json:"attributename"`
	Colorcode                 sql.NullString `json:"colorcode"`
}

func (q *Queries) ListMonstersWithAttribute(ctx context.Context) ([]ListMonstersWithAttributeRow, error) {
	rows, err := q.db.QueryContext(ctx, listMonstersWithAttribute)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMonstersWithAttributeRow{}
	for rows.Next() {
		var i ListMonstersWithAttributeRow
		if err := rows.Scan(
			&i.Monsterid,
			&i.Nickname,
			&i.Originaltrashbinimageurl,
			&i.Generatedmonsterimageurl,
			&i.Latitude,
			&i.Longitude,
			&i.Createdat,
			&i.Updatedat,
			&i.Attributename,
			&i.Colorcode,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMonster = `-- name: UpdateMonster :execresult
UPDATE Monster
SET Nickname = ?, OriginalTrashBinImageUrl = ?, GeneratedMonsterImageUrl = ?, Latitude = ?, Longitude = ?
WHERE MonsterId = ?
`

type UpdateMonsterParams struct {
	Nickname                  string         `json:"nickname"`
	Originaltrashbinimageurl  string         `json:"originaltrashbinimageurl"`
	Generatedmonsterimageurl string         `json:"generatedmonsterimageurl"`
	Latitude                  sql.NullString `json:"latitude"`
	Longitude                 sql.NullString `json:"longitude"`
	Monsterid                 string         `json:"monsterid"`
}

func (q *Queries) UpdateMonster(ctx context.Context, arg UpdateMonsterParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateMonster,
		arg.Nickname,
		arg.Originaltrashbinimageurl,
		arg.Generatedmonsterimageurl,
		arg.Latitude,
		arg.Longitude,
		arg.Monsterid,
	)
}
