// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: monster_trash_category.sql

package mysql

import (
	"context"
	"database/sql"
)

const createMonsterTrashCategory = `-- name: CreateMonsterTrashCategory :execresult
INSERT INTO MonsterTrashCategory (MonsterTrashCategoryId, MonsterId, TrashCategory)
VALUES (?, ?, ?)
`

type CreateMonsterTrashCategoryParams struct {
	Monstertrashcategoryid string `json:"monstertrashcategoryid"`
	Monsterid              string `json:"monsterid"`
	Trashcategory          uint8  `json:"trashcategory"`
}

func (q *Queries) CreateMonsterTrashCategory(ctx context.Context, arg CreateMonsterTrashCategoryParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createMonsterTrashCategory, arg.Monstertrashcategoryid, arg.Monsterid, arg.Trashcategory)
}

const deleteMonsterTrashCategoriesByMonsterId = `-- name: DeleteMonsterTrashCategoriesByMonsterId :exec
DELETE FROM MonsterTrashCategory
WHERE MonsterId = ?
`

func (q *Queries) DeleteMonsterTrashCategoriesByMonsterId(ctx context.Context, monsterid string) error {
	_, err := q.db.ExecContext(ctx, deleteMonsterTrashCategoriesByMonsterId, monsterid)
	return err
}

const deleteMonsterTrashCategory = `-- name: DeleteMonsterTrashCategory :exec
DELETE FROM MonsterTrashCategory
WHERE MonsterTrashCategoryId = ?
`

func (q *Queries) DeleteMonsterTrashCategory(ctx context.Context, monstertrashcategoryid string) error {
	_, err := q.db.ExecContext(ctx, deleteMonsterTrashCategory, monstertrashcategoryid)
	return err
}

const getMonsterTrashCategory = `-- name: GetMonsterTrashCategory :one
SELECT monstertrashcategoryid, monsterid, trashcategory, createdat, updatedat FROM MonsterTrashCategory
WHERE MonsterTrashCategoryId = ? LIMIT 1
`

func (q *Queries) GetMonsterTrashCategory(ctx context.Context, monstertrashcategoryid string) (Monstertrashcategory, error) {
	row := q.db.QueryRowContext(ctx, getMonsterTrashCategory, monstertrashcategoryid)
	var i Monstertrashcategory
	err := row.Scan(
		&i.Monstertrashcategoryid,
		&i.Monsterid,
		&i.Trashcategory,
		&i.Createdat,
		&i.Updatedat,
	)
	return i, err
}

const listMonsterTrashCategories = `-- name: ListMonsterTrashCategories :many
SELECT monstertrashcategoryid, monsterid, trashcategory, createdat, updatedat FROM MonsterTrashCategory
WHERE MonsterId = ?
ORDER BY TrashCategory
`

func (q *Queries) ListMonsterTrashCategories(ctx context.Context, monsterid string) ([]Monstertrashcategory, error) {
	rows, err := q.db.QueryContext(ctx, listMonsterTrashCategories, monsterid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Monstertrashcategory{}
	for rows.Next() {
		var i Monstertrashcategory
		if err := rows.Scan(
			&i.Monstertrashcategoryid,
			&i.Monsterid,
			&i.Trashcategory,
			&i.Createdat,
			&i.Updatedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonstersByTrashCategory = `-- name: ListMonstersByTrashCategory :many
SELECT monstertrashcategoryid, monsterid, trashcategory, createdat, updatedat FROM MonsterTrashCategory
WHERE TrashCategory = ?
ORDER BY CreatedAt DESC
`

func (q *Queries) ListMonstersByTrashCategory(ctx context.Context, trashcategory uint8) ([]Monstertrashcategory, error) {
	rows, err := q.db.QueryContext(ctx, listMonstersByTrashCategory, trashcategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Monstertrashcategory{}
	for rows.Next() {
		var i Monstertrashcategory
		if err := rows.Scan(
			&i.Monstertrashcategoryid,
			&i.Monsterid,
			&i.Trashcategory,
			&i.Createdat,
			&i.Updatedat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
