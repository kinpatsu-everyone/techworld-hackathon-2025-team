package generator

import (
	"bytes"
	"strings"
	"text/template"
	"unicode"

	"github.com/kinpatsu-everyone/backend-template/pkg/outorouter/internal/parser"
)

// toLowerCamel converts PascalCase to camelCase
func toLowerCamel(s string) string {
	if s == "" {
		return s
	}
	r := []rune(s)
	r[0] = unicode.ToLower(r[0])
	return string(r)
}

var templateFuncs = template.FuncMap{
	"toLower":      strings.ToLower,
	"toLowerCamel": toLowerCamel,
}

// TypeScriptClientStrategy は Expo/React Native 向けの型安全な API クライアントコードを生成する。
type TypeScriptClientStrategy struct {
	// BaseURL はAPIのベースURL（開発用デフォルト値）
	BaseURL string
}

func (s TypeScriptClientStrategy) Name() string { return "typescript-client" }

func (s TypeScriptClientStrategy) Generate(meta *parser.Metadata) (string, error) {
	if s.BaseURL == "" {
		s.BaseURL = "http://localhost:8080"
	}

	endpoints := sorted(meta.All)

	// ネストされた型を収集
	nestedTypes := collectNestedTypes(endpoints)

	// エンドポイントごとにTypeScript用のデータを生成
	tsEndpoints := make([]tsEndpointData, 0, len(endpoints))
	hasMultipart := false
	for _, ep := range endpoints {
		isMultipart := ep.Kind == parser.KindFileUpload
		if isMultipart {
			hasMultipart = true
		}
		tsEndpoints = append(tsEndpoints, tsEndpointData{
			Path:               "/" + ep.Path(),
			MethodName:         ep.MethodName,
			HTTPMethod:         ep.HTTPMethod,
			RequestTypeName:    ep.MethodName + "Request",
			ResponseTypeName:   ep.MethodName + "Response",
			Summary:            ep.Summary,
			Tags:               tagsToStrings(ep.Tags),
			RequestTypeFields:  convertFieldsToTS(ep.RequestTypeInfo.Fields),
			ResponseTypeFields: convertFieldsToTS(ep.ResponseTypeInfo.Fields),
			IsMultipart:        isMultipart,
		})
	}

	data := map[string]any{
		"BaseURL":      s.BaseURL,
		"Endpoints":    tsEndpoints,
		"NestedTypes":  nestedTypes,
		"HasMultipart": hasMultipart,
	}

	buf := &bytes.Buffer{}
	tmpl := template.Must(template.New("tsClient").Funcs(templateFuncs).Parse(tsClientTemplate))
	if err := tmpl.Execute(buf, data); err != nil {
		return "", err
	}
	return buf.String(), nil
}

type tsEndpointData struct {
	Path               string
	MethodName         string
	HTTPMethod         string
	RequestTypeName    string
	ResponseTypeName   string
	Summary            string
	Tags               []string
	RequestTypeFields  []tsFieldData
	ResponseTypeFields []tsFieldData
	IsMultipart        bool
}

type tsFieldData struct {
	JSONName   string
	TSType     string
	Optional   bool
	NestedType *tsNestedTypeData
}

type tsNestedTypeData struct {
	Name   string
	Fields []tsFieldData
}

func tagsToStrings(tags []parser.Tag) []string {
	result := make([]string, len(tags))
	for i, t := range tags {
		result[i] = string(t)
	}
	return result
}

// collectNestedTypes は全エンドポイントからネストされた型を収集します
func collectNestedTypes(endpoints []parser.Endpoint) []tsNestedTypeData {
	seenTypes := make(map[string]bool)
	var nestedTypes []tsNestedTypeData

	var collectFromFields func(fields []parser.FieldInfo)
	collectFromFields = func(fields []parser.FieldInfo) {
		for _, f := range fields {
			if f.NestedType != nil && f.NestedType.Name != "" {
				if !seenTypes[f.NestedType.Name] {
					seenTypes[f.NestedType.Name] = true
					nestedTypes = append(nestedTypes, tsNestedTypeData{
						Name:   f.NestedType.Name,
						Fields: convertFieldsToTS(f.NestedType.Fields),
					})
					// 再帰的にネストされた型を収集
					collectFromFields(f.NestedType.Fields)
				}
			}
		}
	}

	for _, ep := range endpoints {
		collectFromFields(ep.RequestTypeInfo.Fields)
		collectFromFields(ep.ResponseTypeInfo.Fields)
	}

	return nestedTypes
}

func convertFieldsToTS(fields []parser.FieldInfo) []tsFieldData {
	result := make([]tsFieldData, len(fields))
	for i, f := range fields {
		fieldData := tsFieldData{
			JSONName: f.JSONName,
			TSType:   f.TSType,
			Optional: f.Optional,
		}
		if f.NestedType != nil && f.NestedType.Name != "" {
			fieldData.NestedType = &tsNestedTypeData{
				Name:   f.NestedType.Name,
				Fields: convertFieldsToTS(f.NestedType.Fields),
			}
		}
		result[i] = fieldData
	}
	return result
}

const tsClientTemplate = `// Code generated by outorouter; DO NOT EDIT.
// This file provides a type-safe API client for Expo/React Native.

// ============================================================================
// Configuration
// ============================================================================

const DEFAULT_BASE_URL = "{{ .BaseURL }}";

export interface ApiClientConfig {
  baseUrl?: string;
  headers?: Record<string, string>;
  onRequest?: (config: RequestConfig) => RequestConfig | Promise<RequestConfig>;
  onResponse?: <T>(response: ApiResponse<T>) => ApiResponse<T> | Promise<ApiResponse<T>>;
  onError?: (error: ApiError) => void;
}

let globalConfig: ApiClientConfig = {
  baseUrl: DEFAULT_BASE_URL,
};

export function configureApiClient(config: ApiClientConfig): void {
  globalConfig = { ...globalConfig, ...config };
}

export function getApiClientConfig(): ApiClientConfig {
  return globalConfig;
}

// ============================================================================
// Types
// ============================================================================

export interface RequestConfig {
  method: string;
  url: string;
  headers: Record<string, string>;
  body?: string;
}

export interface ApiResponse<T> {
  data: T;
  status: number;
  headers: Headers;
}

export interface ApiErrorResponse {
  error: {
    error: string;
    message: string;
  };
}

export class ApiError extends Error {
  constructor(
    public readonly status: number,
    public readonly code: string,
    message: string,
    public readonly response?: Response
  ) {
    super(message);
    this.name = "ApiError";
  }
}

// ============================================================================
// Nested Type Definitions
// ============================================================================
{{- range .NestedTypes }}

/** Nested type: {{ .Name }} */
export interface {{ .Name }} {
{{- if .Fields }}
{{- range .Fields }}
  {{ .JSONName }}{{ if .Optional }}?{{ end }}: {{ .TSType }};
{{- end }}
{{- else }}
  // Empty type
{{- end }}
}
{{- end }}

// ============================================================================
// Request/Response Type Definitions
// ============================================================================
{{- range .Endpoints }}

/** {{ .Summary }} - Request */
export interface {{ .RequestTypeName }} {
{{- if .RequestTypeFields }}
{{- range .RequestTypeFields }}
  {{ .JSONName }}{{ if .Optional }}?{{ end }}: {{ .TSType }};
{{- end }}
{{- else }}
  // Empty request
{{- end }}
}

/** {{ .Summary }} - Response */
export interface {{ .ResponseTypeName }} {
{{- if .ResponseTypeFields }}
{{- range .ResponseTypeFields }}
  {{ .JSONName }}{{ if .Optional }}?{{ end }}: {{ .TSType }};
{{- end }}
{{- else }}
  // Empty response
{{- end }}
}
{{- end }}

// ============================================================================
// Endpoint Path Definitions
// ============================================================================

export const Endpoints = {
{{- range .Endpoints }}
  {{ .MethodName }}: "{{ .Path }}",
{{- end }}
} as const;

export type EndpointPath = (typeof Endpoints)[keyof typeof Endpoints];

// ============================================================================
// Endpoint Type Mapping
// ============================================================================

/**
 * Maps endpoint paths to their request and response types.
 * This enables type inference when calling the API.
 */
export interface EndpointTypes {
{{- range .Endpoints }}
  "{{ .Path }}": {
    request: {{ .RequestTypeName }};
    response: {{ .ResponseTypeName }};
  };
{{- end }}
}

// ============================================================================
// Type-Safe API Client
// ============================================================================

/**
 * Type-safe API client function.
 * The request and response types are automatically inferred from the endpoint path.
 *
 * @example
 * ` + "`" + `` + "`" + `` + "`" + `typescript
 * const response = await api(Endpoints.CreateUser, {
 *   display_name: "John Doe",
 *   email: "john@example.com",
 *   password: "secret123",
 * });
 * // response is typed as CreateUserResponse
 * console.log(response.data.user_id);
 * ` + "`" + `` + "`" + `` + "`" + `
 */
export async function api<P extends keyof EndpointTypes>(
  endpoint: P,
  request: EndpointTypes[P]["request"],
  options?: {
    headers?: Record<string, string>;
    signal?: AbortSignal;
  }
): Promise<ApiResponse<EndpointTypes[P]["response"]>> {
  const config = getApiClientConfig();
  const url = ` + "`" + `${config.baseUrl ?? DEFAULT_BASE_URL}${endpoint}` + "`" + `;

  let requestConfig: RequestConfig = {
    method: "POST",
    url,
    headers: {
      "Content-Type": "application/json",
      ...config.headers,
      ...options?.headers,
    },
    body: JSON.stringify(request),
  };

  // Apply request interceptor
  if (config.onRequest) {
    requestConfig = await config.onRequest(requestConfig);
  }

  const fetchOptions: RequestInit = {
    method: requestConfig.method,
    headers: requestConfig.headers,
    body: requestConfig.body,
    signal: options?.signal,
  };

  const response = await fetch(requestConfig.url, fetchOptions);

  if (!response.ok) {
    let errorData: ApiErrorResponse | null = null;
    try {
      errorData = await response.json();
    } catch {
      // Response body is not JSON
    }

    const apiError = new ApiError(
      response.status,
      errorData?.error?.error ?? "UNKNOWN_ERROR",
      errorData?.error?.message ?? response.statusText,
      response
    );

    if (config.onError) {
      config.onError(apiError);
    }

    throw apiError;
  }

  const data = (await response.json()) as EndpointTypes[P]["response"];

  let result: ApiResponse<EndpointTypes[P]["response"]> = {
    data,
    status: response.status,
    headers: response.headers,
  };

  // Apply response interceptor
  if (config.onResponse) {
    result = await config.onResponse(result);
  }

  return result;
}

// ============================================================================
// Convenience Hooks for React/Expo (Optional)
// ============================================================================

/**
 * Creates a typed API caller for a specific endpoint.
 * Useful for creating reusable API functions.
 *
 * @example
 * ` + "`" + `` + "`" + `` + "`" + `typescript
 * const createUser = createApiCaller(Endpoints.CreateUser);
 * const response = await createUser({ display_name: "John", email: "..." });
 * ` + "`" + `` + "`" + `` + "`" + `
 */
export function createApiCaller<P extends keyof EndpointTypes>(endpoint: P) {
  return (
    request: EndpointTypes[P]["request"],
    options?: {
      headers?: Record<string, string>;
      signal?: AbortSignal;
    }
  ) => api(endpoint, request, options);
}

// ============================================================================
// Pre-configured API Callers
// ============================================================================

export const apiCallers = {
{{- range .Endpoints }}
  /** {{ .Summary }} */
  {{ .MethodName }}: createApiCaller(Endpoints.{{ .MethodName }}),
{{- end }}
};
{{- if .HasMultipart }}

// ============================================================================
// Multipart API Client (for file uploads)
// ============================================================================

/**
 * API client for multipart/form-data requests.
 * Used for file uploads.
 */
export async function apiMultipart<T>(
  endpoint: string,
  formData: FormData,
  options?: {
    headers?: Record<string, string>;
    signal?: AbortSignal;
  }
): Promise<ApiResponse<T>> {
  const config = getApiClientConfig();
  const url = ` + "`" + `${config.baseUrl ?? DEFAULT_BASE_URL}${endpoint}` + "`" + `;

  const fetchOptions: RequestInit = {
    method: "POST",
    headers: {
      ...config.headers,
      ...options?.headers,
    },
    body: formData,
    signal: options?.signal,
  };

  const response = await fetch(url, fetchOptions);

  if (!response.ok) {
    let errorData: ApiErrorResponse | null = null;
    try {
      errorData = await response.json();
    } catch {
      // Response body is not JSON
    }

    const apiError = new ApiError(
      response.status,
      errorData?.error?.error ?? "UNKNOWN_ERROR",
      errorData?.error?.message ?? response.statusText,
      response
    );

    if (config.onError) {
      config.onError(apiError);
    }

    throw apiError;
  }

  const data = (await response.json()) as T;

  let result: ApiResponse<T> = {
    data,
    status: response.status,
    headers: response.headers,
  };

  if (config.onResponse) {
    result = await config.onResponse(result);
  }

  return result;
}

// ============================================================================
// Multipart Helper Functions
// ============================================================================
{{- range .Endpoints }}
{{- if .IsMultipart }}

export interface {{ .MethodName }}Params {
{{- range .RequestTypeFields }}
{{- if eq .TSType "FileHeader" }}
  {{ .JSONName }}: string; // File URI (e.g., "file:///path/to/photo.jpg")
{{- else }}
  {{ .JSONName }}{{ if .Optional }}?{{ end }}: {{ .TSType }};
{{- end }}
{{- end }}
}

/**
 * {{ .Summary }}
 * Uploads files using multipart/form-data.
 */
export async function {{ .MethodName | toLowerCamel }}(
  params: {{ .MethodName }}Params,
  options?: {
    headers?: Record<string, string>;
    signal?: AbortSignal;
  }
): Promise<ApiResponse<{{ .ResponseTypeName }}>> {
  const formData = new FormData();
{{- range .RequestTypeFields }}
{{- if eq .TSType "FileHeader" }}
  formData.append("{{ .JSONName }}", {
    uri: params.{{ .JSONName }},
    type: "image/jpeg",
    name: "photo.jpg",
  } as unknown as Blob);
{{- else }}
  formData.append("{{ .JSONName }}", String(params.{{ .JSONName }}));
{{- end }}
{{- end }}

  return apiMultipart<{{ .ResponseTypeName }}>(
    Endpoints.{{ .MethodName }},
    formData,
    options
  );
}
{{- end }}
{{- end }}
{{- end }}
`
